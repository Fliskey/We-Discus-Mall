"use strict";
const fs = require("fs");
const path = require("path");
const util_1 = require("util");
async function copy(sourcePath, targetPath, options) {
    const lchown = util_1.promisify(fs.lchown);
    const copyFile = util_1.promisify(fs.copyFile);
    const lstat = util_1.promisify(fs.lstat);
    const mkdir = util_1.promisify(fs.mkdir);
    const readdir = util_1.promisify(fs.readdir);
    const readFile = util_1.promisify(fs.readFile);
    const readlink = util_1.promisify(fs.readlink);
    const symlink = util_1.promisify(fs.symlink);
    const unlink = util_1.promisify(fs.unlink);
    const utimes = util_1.promisify(fs.utimes);
    const writeFile = util_1.promisify(fs.writeFile);
    const defaultOptions = {
        overwrite: true,
        errorOnExist: false,
        dereference: false,
        preserveTimestamps: false,
        dryRun: false,
    };
    const { overwrite, errorOnExist, dereference, preserveTimestamps, chown, chgrp, dryRun, filter, transform } = Object.assign(defaultOptions, options);
    const flag = overwrite ? 'w' : 'wx';
    const [directories, files, symlinks, size] = await cpPath(sourcePath, targetPath, [0, 0, 0, 0]);
    return {
        directories,
        files,
        symlinks,
        size,
    };
    async function cpPath(source, target, subTotals) {
        const sourceStats = await lstat(source);
        const targetStats = await lstat(target).catch(ENOENT);
        if (!filter || await Promise.resolve(filter(source, target, sourceStats, targetStats))) {
            if (errorOnExist && targetStats && !overwrite) {
                throw Error(`target already exists: ${target}`);
            }
            if (sourceStats.isFile() || (dereference && sourceStats.isSymbolicLink())) {
                const fileSize = await cpFile(source, target, sourceStats, targetStats);
                subTotals[1] += 1;
                subTotals[3] += fileSize;
            }
            else if (sourceStats.isDirectory()) {
                await cpDir(source, target, sourceStats, targetStats, subTotals);
                subTotals[0] += 1;
            }
            else if (sourceStats.isSymbolicLink()) {
                const symlinkSize = await cpSymlink(source, target, sourceStats, targetStats);
                subTotals[2] += 1;
                subTotals[3] += symlinkSize;
            }
            if (!dryRun) {
                if (preserveTimestamps && (!targetStats || overwrite)) {
                    if (!sourceStats.isSymbolicLink()) {
                        await utimes(target, sourceStats.atime, sourceStats.mtime);
                    }
                }
                if (chown || chgrp) {
                    await lchown(target, chown || sourceStats.uid, chgrp || sourceStats.gid);
                }
            }
        }
        return subTotals;
    }
    async function cpDir(source, target, sourceStats, targetStats, subTotals) {
        if (!dryRun && !targetStats) {
            await mkdir(target, { recursive: true, mode: sourceStats.mode });
        }
        await Promise.all((await readdir(source)).map(async (child) => cpPath(path.join(source, child), path.join(target, child), subTotals)));
    }
    async function cpFile(source, target, sourceStats, targetStats) {
        if (transform) {
            const data = await Promise.resolve(transform(await readFile(source), source, target, sourceStats, targetStats));
            if (!dryRun && (!targetStats || overwrite)) {
                await writeFile(target, data, { mode: sourceStats.mode, flag });
            }
            return data.length;
        }
        else if (!targetStats || overwrite) {
            if (!dryRun) {
                await copyFile(source, target);
            }
            return sourceStats.size;
        }
        else {
            return 0;
        }
    }
    async function cpSymlink(source, target, sourceStats, targetStats) {
        if (!targetStats || overwrite) {
            const link = await readlink(source);
            if (!dryRun) {
                if (targetStats) {
                    await unlink(target);
                }
                await symlink(link, target);
            }
            return sourceStats.size;
        }
        else {
            return 0;
        }
    }
    async function ENOENT(err) {
        if (err.code === 'ENOENT') {
            return undefined;
        }
        else {
            throw err;
        }
    }
}
module.exports = copy;
//# sourceMappingURL=index.js.map