import { flatten, isString, valuesOfKey } from '@antv/util';
import { getXDimensionLength } from '../../util/coordinate';
// 已经排序后的数据查找距离最小的
function findMinDistance(arr, scale) {
    var count = arr.length;
    var sourceArr = arr;
    if (isString(sourceArr[0])) {
        // 日期类型的 values 经常上文本类型，所以需要转换一下
        sourceArr = arr.map(function (v) {
            return scale.translate(v);
        });
    }
    var distance = sourceArr[1] - sourceArr[0];
    for (var i = 2; i < count; i++) {
        var tmp = sourceArr[i] - sourceArr[i - 1];
        if (distance > tmp) {
            distance = tmp;
        }
    }
    return distance;
}
function getDodgeCount(dataArray, dodgeBy) {
    if (dodgeBy) {
        var mergeData = flatten(dataArray);
        var values = valuesOfKey(mergeData, dodgeBy);
        return values.length;
    }
    return dataArray.length;
}
/** @ignore */
export function getDefaultSize(geometry) {
    var theme = geometry.theme;
    var coordinate = geometry.coordinate;
    var xScale = geometry.getXScale();
    var xValues = xScale.values;
    var dataArray = geometry.beforeMappingData;
    var count = xValues.length;
    if (xScale.isLinear && xValues.length > 1) {
        // Linear 类型用户有可能设置了 min, max 范围所以需要根据数据最小区间计算 count
        xValues.sort();
        var interval = findMinDistance(xValues, xScale);
        count = (xScale.max - xScale.min) / interval;
        if (xValues.length > count) {
            count = xValues.length;
        }
    }
    var range = xScale.range;
    var normalizedSize = 1 / count;
    var wr = 1;
    if (coordinate.isPolar) {
        if (coordinate.isTransposed && count > 1) {
            // 极坐标下多层环图
            wr = theme.multiplePieWidthRatio;
        }
        else {
            wr = theme.roseWidthRatio;
        }
    }
    else {
        if (xScale.isLinear) {
            normalizedSize *= range[1] - range[0];
        }
        wr = theme.columnWidthRatio;
    }
    normalizedSize *= wr;
    if (geometry.getAdjust('dodge')) {
        var dodgeAdjust = geometry.getAdjust('dodge');
        var dodgeBy = dodgeAdjust.dodgeBy;
        var dodgeCount = getDodgeCount(dataArray, dodgeBy);
        normalizedSize = normalizedSize / dodgeCount;
    }
    // 最大和最小限制
    var maxColumnWidth = theme.maxColumnWidth, minColumnWidth = theme.minColumnWidth;
    var xDimensionLength = getXDimensionLength(geometry.coordinate);
    if (maxColumnWidth) {
        var normalizedMaxColumnWidth = maxColumnWidth / xDimensionLength;
        if (normalizedSize > normalizedMaxColumnWidth) {
            normalizedSize = normalizedMaxColumnWidth;
        }
    }
    if (minColumnWidth) {
        var normalizedMinColumnWidth = minColumnWidth / xDimensionLength;
        if (normalizedSize < normalizedMinColumnWidth) {
            normalizedSize = normalizedMinColumnWidth;
        }
    }
    return normalizedSize;
}
//# sourceMappingURL=shape-size.js.map