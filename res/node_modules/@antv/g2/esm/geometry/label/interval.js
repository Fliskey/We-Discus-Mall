import { __extends } from "tslib";
import { get } from '@antv/util';
import GeometryLabel from './base';
/**
 * 柱状图 label
 */
var IntervalLabel = /** @class */ (function (_super) {
    __extends(IntervalLabel, _super);
    function IntervalLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IntervalLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {
        var coordinate = this.getCoordinate();
        var transposed = coordinate.isTransposed;
        var shapePoints = mappingData.points;
        var point0 = coordinate.convert(shapePoints[0]);
        var point1 = coordinate.convert(shapePoints[2]);
        var flag = transposed ? -1 : 1;
        var width = ((point0.x - point1.x) / 2) * flag;
        var height = ((point0.y - point1.y) / 2) * flag;
        switch (position) {
            case 'right':
                if (!transposed) {
                    labelPointCfg.x -= width;
                    labelPointCfg.y += height;
                }
                labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'left');
                break;
            case 'left':
                if (transposed) {
                    labelPointCfg.x -= width * 2;
                }
                else {
                    labelPointCfg.x += width;
                    labelPointCfg.y += height;
                }
                labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'right');
                break;
            case 'bottom':
                if (transposed) {
                    labelPointCfg.x -= width;
                    labelPointCfg.y -= height;
                }
                else {
                    labelPointCfg.y += height * 2;
                }
                labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');
                labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', 'top');
                break;
            case 'middle':
                if (transposed) {
                    labelPointCfg.x -= width;
                }
                else {
                    labelPointCfg.y += height;
                }
                labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');
                break;
            case 'top':
                if (transposed) {
                    labelPointCfg.x -= width;
                    labelPointCfg.y += height;
                }
                labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');
                labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', 'bottom');
                break;
            default:
                break;
        }
    };
    return IntervalLabel;
}(GeometryLabel));
export default IntervalLabel;
//# sourceMappingURL=interval.js.map