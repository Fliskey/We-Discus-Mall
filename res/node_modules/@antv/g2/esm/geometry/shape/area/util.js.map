{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../src/geometry/shape/area/util.ts"],"names":[],"mappings":"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","sourcesContent":["import { each } from '@antv/util';\nimport { Coordinate, PathCommand } from '../../../dependents';\nimport { Point, Position, Shape, ShapeInfo } from '../../../interface';\n\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\n\nfunction getPath(\n  points: Point[],\n  isInCircle: boolean,\n  smooth: boolean,\n  registeredShape: Shape,\n  constraint?: Position[]\n): PathCommand[] {\n  const topLinePoints = []; // area 区域上部分\n  let bottomLinePoints = []; // area 区域下部分\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    topLinePoints.push(point[1]);\n    bottomLinePoints.push(point[0]);\n  }\n  bottomLinePoints = bottomLinePoints.reverse();\n\n  let path = [];\n  each([topLinePoints, bottomLinePoints], (pointsData, index) => {\n    let subPath = [];\n    const parsedPoints = registeredShape.parsePoints(pointsData);\n    const p1 = parsedPoints[0];\n    if (isInCircle) {\n      parsedPoints.push({ x: p1.x, y: p1.y });\n    }\n    if (smooth) {\n      subPath = getSplinePath(parsedPoints, false, constraint);\n    } else {\n      subPath = getLinePath(parsedPoints, false);\n    }\n\n    if (index > 0) {\n      subPath[0][0] = 'L';\n    }\n    path = path.concat(subPath);\n  });\n\n  path.push(['Z']);\n  return path;\n}\n\n/**\n * @ignore\n * Gets shape attrs\n * @param cfg\n * @param isStroke\n * @param smooth\n * @param registeredShape\n * @param [constraint]\n * @returns\n */\nexport function getShapeAttrs(\n  cfg: ShapeInfo,\n  isStroke: boolean,\n  smooth: boolean,\n  registeredShape: Shape,\n  constraint?: Position[]\n) {\n  const attrs = getStyle(cfg, isStroke, !isStroke, 'lineWidth');\n  const { connectNulls, isInCircle, points } = cfg;\n  const pathPoints = getPathPoints(points, connectNulls); // 根据 connectNulls 配置获取图形关键点\n\n  let path = [];\n  for (let i = 0, len = pathPoints.length; i < len; i++) {\n    const eachPoints = pathPoints[i];\n    path = path.concat(getPath(eachPoints, isInCircle, smooth, registeredShape, constraint));\n  }\n  attrs.path = path;\n\n  return attrs;\n}\n\n/**\n * @ignore\n * Gets constraint\n * @param coordinate\n * @returns constraint\n */\nexport function getConstraint(coordinate: Coordinate): Position[] {\n  const { start, end } = coordinate;\n  return [\n    [start.x, end.y],\n    [end.x, start.y],\n  ];\n}\n"]}