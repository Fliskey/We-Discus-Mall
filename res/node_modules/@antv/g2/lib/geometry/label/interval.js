"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var util_1 = require("@antv/util");
var base_1 = tslib_1.__importDefault(require("./base"));
/**
 * 柱状图 label
 */
var IntervalLabel = /** @class */ (function (_super) {
    tslib_1.__extends(IntervalLabel, _super);
    function IntervalLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IntervalLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {
        var coordinate = this.getCoordinate();
        var transposed = coordinate.isTransposed;
        var shapePoints = mappingData.points;
        var point0 = coordinate.convert(shapePoints[0]);
        var point1 = coordinate.convert(shapePoints[2]);
        var flag = transposed ? -1 : 1;
        var width = ((point0.x - point1.x) / 2) * flag;
        var height = ((point0.y - point1.y) / 2) * flag;
        switch (position) {
            case 'right':
                if (!transposed) {
                    labelPointCfg.x -= width;
                    labelPointCfg.y += height;
                }
                labelPointCfg.textAlign = util_1.get(labelPointCfg, 'textAlign', 'left');
                break;
            case 'left':
                if (transposed) {
                    labelPointCfg.x -= width * 2;
                }
                else {
                    labelPointCfg.x += width;
                    labelPointCfg.y += height;
                }
                labelPointCfg.textAlign = util_1.get(labelPointCfg, 'textAlign', 'right');
                break;
            case 'bottom':
                if (transposed) {
                    labelPointCfg.x -= width;
                    labelPointCfg.y -= height;
                }
                else {
                    labelPointCfg.y += height * 2;
                }
                labelPointCfg.textAlign = util_1.get(labelPointCfg, 'textAlign', 'center');
                labelPointCfg.textBaseline = util_1.get(labelPointCfg, 'textBaseline', 'top');
                break;
            case 'middle':
                if (transposed) {
                    labelPointCfg.x -= width;
                }
                else {
                    labelPointCfg.y += height;
                }
                labelPointCfg.textAlign = util_1.get(labelPointCfg, 'textAlign', 'center');
                break;
            case 'top':
                if (transposed) {
                    labelPointCfg.x -= width;
                    labelPointCfg.y += height;
                }
                labelPointCfg.textAlign = util_1.get(labelPointCfg, 'textAlign', 'center');
                labelPointCfg.textBaseline = util_1.get(labelPointCfg, 'textBaseline', 'bottom');
                break;
            default:
                break;
        }
    };
    return IntervalLabel;
}(base_1.default));
exports.default = IntervalLabel;
//# sourceMappingURL=interval.js.map